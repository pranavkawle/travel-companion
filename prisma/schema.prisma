// This is your Prisma schema file
// Learn more: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "sqlserver"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

// ============================================================================
// USER MANAGEMENT
// ============================================================================

/// User profile - core identity managed by Auth0
/// Mobile number and email stored in Auth0 user_metadata (not in this table)
model User {
  id             String   @id @default(uuid())
  auth0Id        String   @unique @db.NVarChar(1000)
  email          String?  @db.VarChar(255)
  firstName      String   @db.VarChar(50)
  mobileNumber   String?  @db.VarChar(20)
  languages      String   @db.NVarChar(Max) // JSON string: ["en", "es", "fr"]
  accountStatus  String   @default("ACTIVE") @db.VarChar(20) // ACTIVE, SUSPENDED, BLOCKED
  mobileVerified Boolean  @default(false) // Synced from Auth0
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  // Relationships
  flights              Flight[]
  sentMessages         Message[]       @relation("SentMessages")
  receivedMessages     Message[]       @relation("ReceivedMessages")
  conversationsAsP1    Conversation[]  @relation("ConversationParticipant1")
  conversationsAsP2    Conversation[]  @relation("ConversationParticipant2")
  givenRatings         Rating[]        @relation("GivenRatings")
  receivedRatings      Rating[]        @relation("ReceivedRatings")
  reportsFiled         Report[]        @relation("ReportsFiled")
  reportsReceived      Report[]        @relation("ReportsReceived")
  blockedUsers         Block[]         @relation("Blocker")
  blockedBy            Block[]         @relation("Blocked")

  @@index([accountStatus])
  @@index([mobileVerified])
  @@map("Users")
}

// ============================================================================
// FLIGHT & TRAVEL
// ============================================================================

/// Flight details for travel matching
/// Auto-deleted 30 days after travelDate
model Flight {
  id                  String   @id @default(uuid())
  userId              String
  sourceAirport       String   @db.Char(3)  // IATA code (e.g., "SYD")
  destinationAirport  String   @db.Char(3)  // IATA code (e.g., "MEL")
  travelDate          DateTime @db.Date
  flightNumber        String?  @db.VarChar(10) // Optional (e.g., "QF123")
  dataSource          String   @default("MANUAL") @db.VarChar(20) // MANUAL, IMPORTED
  createdAt           DateTime @default(now())
  
  // Relationships
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversations Conversation[]
  ratings       Rating[]

  @@index([userId])
  @@index([sourceAirport, destinationAirport, travelDate]) // Search optimization
  @@index([travelDate]) // Cleanup job optimization
  @@map("Flights")
}

// ============================================================================
// MESSAGING
// ============================================================================

/// Conversation container for message threads
/// One conversation per user pair per flight
/// Auto-deleted 60 days after flight's travelDate
model Conversation {
  id              String    @id @default(uuid())
  flightId        String
  participant1Id  String
  participant2Id  String
  status          String    @default("ACTIVE") @db.VarChar(20) // ACTIVE, ARCHIVED, BLOCKED
  createdAt       DateTime  @default(now())
  closedAt        DateTime?
  
  // Relationships
  flight       Flight    @relation(fields: [flightId], references: [id], onDelete: Cascade)
  participant1 User      @relation("ConversationParticipant1", fields: [participant1Id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  participant2 User      @relation("ConversationParticipant2", fields: [participant2Id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  messages     Message[]

  @@unique([flightId, participant1Id, participant2Id])
  @@index([participant1Id, participant2Id])
  @@index([status])
  @@map("Conversations")
}

/// Individual message in a conversation
/// Cascade deleted when conversation is deleted
model Message {
  id             String    @id @default(uuid())
  conversationId String
  senderId       String
  recipientId    String
  content        String    @db.NVarChar(Max) // Max 10,000 characters
  sentAt         DateTime  @default(now())
  readAt         DateTime?
  
  // Relationships
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("SentMessages", fields: [senderId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  recipient    User         @relation("ReceivedMessages", fields: [recipientId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@index([conversationId, sentAt]) // Chronological retrieval
  @@index([recipientId, readAt])    // Unread message queries
  @@map("Messages")
}

// ============================================================================
// RATINGS & FEEDBACK
// ============================================================================

/// Post-travel rating (1-5 stars + optional feedback)
/// One rating per user pair per flight
/// Preserved even if user account is blocked
model Rating {
  id        String   @id @default(uuid())
  flightId  String
  raterId   String
  rateeId   String
  stars     Int      // 1-5 (validated in application layer)
  feedback  String?  @db.NVarChar(500)
  createdAt DateTime @default(now())
  
  // Relationships
  flight Flight @relation(fields: [flightId], references: [id], onDelete: Cascade)
  rater  User   @relation("GivenRatings", fields: [raterId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  ratee  User   @relation("ReceivedRatings", fields: [rateeId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@unique([flightId, raterId, rateeId])
  @@index([rateeId]) // Aggregate rating queries
  @@map("Ratings")
}

// ============================================================================
// REPORTING & MODERATION
// ============================================================================

/// User-generated report of inappropriate behavior
/// Triaged by priority (critical/standard)
model Report {
  id             String    @id @default(uuid())
  reporterId     String
  reportedUserId String
  reportType     String    @db.VarChar(30) // HARASSMENT, SPAM, INAPPROPRIATE_CONTENT, SAFETY_CONCERN, SCAM_ATTEMPT
  description    String    @db.NVarChar(1000)
  status         String    @default("PENDING") @db.VarChar(20) // PENDING, UNDER_REVIEW, RESOLVED, DISMISSED
  priority       String    @db.VarChar(20) // CRITICAL, STANDARD
  createdAt      DateTime  @default(now())
  reviewedAt     DateTime?
  reviewedBy     String?
  
  // Relationships
  reporter     User           @relation("ReportsFiled", fields: [reporterId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  reportedUser User           @relation("ReportsReceived", fields: [reportedUserId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  reviewer     Administrator? @relation(fields: [reviewedBy], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@index([status, priority, createdAt]) // Admin queue optimization
  @@index([reportedUserId])              // Pattern analysis
  @@map("Reports")
}

/// User blocking relationship
/// Blocked users excluded from search, cannot send messages
model Block {
  id        String   @id @default(uuid())
  blockerId String
  blockedId String
  reason    String?  @db.NVarChar(500)
  createdAt DateTime @default(now())
  
  // Relationships
  blocker User @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("Blocked", fields: [blockedId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@unique([blockerId, blockedId])
  @@index([blockedId]) // Check if user is blocked before showing in results
  @@map("Blocks")
}

// ============================================================================
// ADMINISTRATION
// ============================================================================

/// System administrator account
/// All admins have equal privileges (no role hierarchy)
model Administrator {
  id              String          @id @default(uuid())
  email           String          @unique @db.VarChar(255)
  createdAt       DateTime        @default(now())
  createdBy       String?
  
  // Relationships
  creator         Administrator?  @relation("AdminCreatedBy", fields: [createdBy], references: [id], onDelete: NoAction, onUpdate: NoAction)
  createdAdmins   Administrator[] @relation("AdminCreatedBy")
  reviewedReports Report[]

  @@index([email])
  @@map("Administrators")
}
