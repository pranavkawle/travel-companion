// This is your Prisma schema file
// Learn more: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USER MANAGEMENT
// ============================================================================

/// User profile - core identity managed by Auth0
/// Mobile number and email stored in Auth0 user_metadata (not in this table)
model User {
  id             String         @id @default(uuid())
  firstName      String         @db.VarChar(50)
  languages      Json           // Array of ISO 639-1 codes: ["en", "es", "fr"]
  accountStatus  AccountStatus  @default(ACTIVE)
  mobileVerified Boolean        @default(false) // Synced from Auth0
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  
  // Relationships
  flights              Flight[]
  sentMessages         Message[]       @relation("SentMessages")
  receivedMessages     Message[]       @relation("ReceivedMessages")
  conversationsAsP1    Conversation[]  @relation("ConversationParticipant1")
  conversationsAsP2    Conversation[]  @relation("ConversationParticipant2")
  givenRatings         Rating[]        @relation("GivenRatings")
  receivedRatings      Rating[]        @relation("ReceivedRatings")
  reportsFiled         Report[]        @relation("ReportsFiled")
  reportsReceived      Report[]        @relation("ReportsReceived")
  blockedUsers         Block[]         @relation("Blocker")
  blockedBy            Block[]         @relation("Blocked")

  @@index([accountStatus])
  @@index([mobileVerified])
  @@map("Users")
}

enum AccountStatus {
  ACTIVE
  SUSPENDED
  BLOCKED
}

// ============================================================================
// FLIGHT & TRAVEL
// ============================================================================

/// Flight details for travel matching
/// Auto-deleted 30 days after travelDate
model Flight {
  id                  String         @id @default(uuid())
  userId              String
  sourceAirport       String         @db.Char(3)  // IATA code (e.g., "SYD")
  destinationAirport  String         @db.Char(3)  // IATA code (e.g., "MEL")
  travelDate          DateTime       @db.Date
  flightNumber        String?        @db.VarChar(10) // Optional (e.g., "QF123")
  dataSource          DataSource     @default(MANUAL)
  createdAt           DateTime       @default(now())
  
  // Relationships
  user                User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversations       Conversation[]
  ratings             Rating[]

  @@index([userId])
  @@index([sourceAirport, destinationAirport, travelDate]) // Search optimization
  @@index([travelDate]) // Cleanup job optimization
  @@map("Flights")
}

enum DataSource {
  MANUAL
  IMPORTED
}

// ============================================================================
// MESSAGING
// ============================================================================

/// Conversation container for message threads
/// One conversation per user pair per flight
/// Auto-deleted 60 days after flight's travelDate
model Conversation {
  id              String              @id @default(uuid())
  flightId        String
  participant1Id  String
  participant2Id  String
  status          ConversationStatus  @default(ACTIVE)
  createdAt       DateTime            @default(now())
  closedAt        DateTime?
  
  // Relationships
  flight          Flight              @relation(fields: [flightId], references: [id], onDelete: Cascade)
  participant1    User                @relation("ConversationParticipant1", fields: [participant1Id], references: [id])
  participant2    User                @relation("ConversationParticipant2", fields: [participant2Id], references: [id])
  messages        Message[]

  @@unique([flightId, participant1Id, participant2Id])
  @@index([participant1Id, participant2Id])
  @@index([status])
  @@map("Conversations")
}

enum ConversationStatus {
  ACTIVE
  ARCHIVED
  BLOCKED
}

/// Individual message in a conversation
/// Cascade deleted when conversation is deleted
model Message {
  id              String       @id @default(uuid())
  conversationId  String
  senderId        String
  recipientId     String
  content         String       @db.NVarChar(Max) // Max 10,000 characters
  sentAt          DateTime     @default(now())
  readAt          DateTime?
  
  // Relationships
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender          User         @relation("SentMessages", fields: [senderId], references: [id])
  recipient       User         @relation("ReceivedMessages", fields: [recipientId], references: [id])

  @@index([conversationId, sentAt]) // Chronological retrieval
  @@index([recipientId, readAt])    // Unread message queries
  @@map("Messages")
}

// ============================================================================
// RATINGS & FEEDBACK
// ============================================================================

/// Post-travel rating (1-5 stars + optional feedback)
/// One rating per user pair per flight
/// Preserved even if user account is blocked
model Rating {
  id        String    @id @default(uuid())
  flightId  String
  raterId   String
  rateeId   String
  stars     Int       // 1-5 (validated in application layer)
  feedback  String?   @db.NVarChar(500)
  createdAt DateTime  @default(now())
  
  // Relationships
  flight    Flight    @relation(fields: [flightId], references: [id], onDelete: Cascade)
  rater     User      @relation("GivenRatings", fields: [raterId], references: [id])
  ratee     User      @relation("ReceivedRatings", fields: [rateeId], references: [id])

  @@unique([flightId, raterId, rateeId])
  @@index([rateeId]) // Aggregate rating queries
  @@map("Ratings")
}

// ============================================================================
// REPORTING & MODERATION
// ============================================================================

/// User-generated report of inappropriate behavior
/// Triaged by priority (critical/standard)
model Report {
  id              String         @id @default(uuid())
  reporterId      String
  reportedUserId  String
  reportType      ReportType
  description     String         @db.NVarChar(1000)
  status          ReportStatus   @default(PENDING)
  priority        ReportPriority
  createdAt       DateTime       @default(now())
  reviewedAt      DateTime?
  reviewedBy      String?
  
  // Relationships
  reporter        User           @relation("ReportsFiled", fields: [reporterId], references: [id])
  reportedUser    User           @relation("ReportsReceived", fields: [reportedUserId], references: [id])
  reviewer        Administrator? @relation(fields: [reviewedBy], references: [id])

  @@index([status, priority, createdAt]) // Admin queue optimization
  @@index([reportedUserId])              // Pattern analysis
  @@map("Reports")
}

enum ReportType {
  HARASSMENT
  SPAM
  INAPPROPRIATE_CONTENT
  SAFETY_CONCERN
  SCAM_ATTEMPT
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

enum ReportPriority {
  CRITICAL // harassment, safety_concern, scam_attempt
  STANDARD // spam, inappropriate_content
}

/// User blocking relationship
/// Blocked users excluded from search, cannot send messages
model Block {
  id        String    @id @default(uuid())
  blockerId String
  blockedId String
  reason    String?   @db.NVarChar(500)
  createdAt DateTime  @default(now())
  
  // Relationships
  blocker   User      @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked   User      @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockedId]) // Check if user is blocked before showing in results
  @@map("Blocks")
}

// ============================================================================
// ADMINISTRATION
// ============================================================================

/// System administrator account
/// All admins have equal privileges (no role hierarchy)
model Administrator {
  id              String          @id @default(uuid())
  email           String          @unique @db.VarChar(255)
  createdAt       DateTime        @default(now())
  createdBy       String?
  
  // Relationships
  creator         Administrator?  @relation("AdminCreatedBy", fields: [createdBy], references: [id])
  createdAdmins   Administrator[] @relation("AdminCreatedBy")
  reviewedReports Report[]

  @@index([email])
  @@map("Administrators")
}
